+++
highlight = true
math = false
date = "2017-07-10T10:09:32-04:00"
title = "A Tutorial on TACO Tensor Algebra Compiler"
tags = ["taco"]

[header]
  caption = ""
  image = ""

+++

<!--more-->

# Important classes 

The few important classes for taco are following. Most of the header files are 
under include/taco/ and the .cpp files are in src/

-- Format
-- Tensor

## Format
Format class has the following data structures: 

-- a vector of modeTypes ( ModeType can be dense, sparse or Fixed )
-- a vector of modeOrdering. (Mode ordering is just the order in which different dimensions are stored.)

## TensorBase
It has:

Content *content
std::shared_ptr<std::vector<char>> coordinateBuffer  // stores all the indices followed by the element in the tensor
int coordinateBufferUsed
int coordinateSize // space occupied by all the indices and a single data element

TensorBase has struct Content defined in .cpp file. It has following important 
members

Contents
-- vector<int> dimensions // stores the vector of int passed as the max elements in each dimension
-- storage::Storage storage // stores Storage(Format) where Format is what we pass in during tensor creation
-- vector<IndexVar> indexVars
-- IndexExpr expr
-- vector<void*> arguments
-- lower::Iterationschedule schedule
-- Stmt assembleFunc // to be generated by the lowering
-- Stmt computeFunc  // to be generated by the lowering
-- Module* module

-- insert(list<int> cordinate, double value) method in TensorBase stores all the
elements in the coordinate list into coordinateBuffer->data()[coordinateBufferUsed]
and then stores the value after that. Call data() on the vector returns the underlying array. 

-- pack() method -- rearranges entries in the coordinateBuffer and then calls pack() 
     on storage which allocates the index, pos etc arrays

-- compile() {
     // compile method is only called for the result tensor.
     content->assembleFunc = lower::lower(*this, "assemble", assembleProperties); // lower:Assemble is set 
     content->computeFunc  = lower::lower(*this, "compute", computeProperties); // lower::Compute is set
     // Adds these two IR functions to the module
     content->module->addFunction(content->assembleFunc);
     content->module->addFunction(content->computeFunc);
     // Converts the functions which are in IR into C code using visitor
     content->module->compile();
   }

## Storage
in include/taco/storage/storage.h. It has a shared pointer to contents which is

Contents:
  -- Format format
  -- Index index
  -- Array values

### IndexVar
The definition can be found in include/taco/expr.h. It just has a Content variable

struct IndexVar::Content {
  std::string name;
};

### IndexExpr
An index expression is a primary expression that produces an array element when it is evaluated. The value produced by an index expression is a variable; it can be used as the left operand of an assignment expression. The data type of an index expression is the data type of the array element produced by the expression:

source: http://bioinfo2.ugr.es/OReillyReferenceLibrary/java/langref/ch04_js.htm

Because of the precedence of Java expressions, an array allocation expression can only be indexed when the expression is enclosed in parentheses. For example:

(new int[6])[3]
This expression refers to the fourth element of the newly created array. Leaving out the parentheses results in the following:

new int[6][3]
This is not an index expression, but an array allocation expression that allocates an array of 3 arrays of 6 integers

This class is defined in include/taco/expr.h




## Tensor
It has a class definition of class const_iterator. The const_iterattor has following
members:

### const_iterator
-- Tensor* tensor
-- vector<int> coord
-- vector<int> ptrs
-- std::pair<vector<int>, CType> curVal
-- int count
-- bool advance


## Lower
It is in include/taco/lower/

struct Context {
  /// Determines what kind of code to emit (e.g. compute and/or assembly)
  set<Property>        properties;
  IterationSchedule    schedule;

  /// The iterators of the tensor tree levels
  Iterators            iterators;

  map<TensorBase,Expr> temporaries;
}

Stmt lower(TensorBase tensor, string funcName, set<Property> properties) {

  Context ctx;

  // parameters are the operands in the tensor expression in ir::Expr form
  // results is tensor itself in ir::Expr form
  // tensorVars is a map of tensors in expression and their ir::Expr form
  tie(parameters,results,tensorVars) = getTensorVars(tensor);

  // Create the schedule and the iterators of the lowered code
  ctx.schedule = IterationSchedule::make(tensor);
  ctx.iterators = Iterators(ctx.schedule, tensorVars);


}

## IterationSchedule
It is in src/lower/iteration_schedule.cpp

IterationSchedule just has a Contents variable:

struct IterationSchedule::Content {
  TensorBase                             tensor; // result tensor
  IterationScheduleForest                scheduleForest;  
  TensorPath                             resultTensorPath; // tensor path for result tensor
  vector<TensorPath>                     tensorPaths; // all tensor paths
  map<IndexExpr,TensorPath>              mapAccessNodesToPaths;
};


IterationSchedule IterationSchedule::make(const TensorBase& tensor) {
  // Create the tensor path formed by the result.
  vector<IndexVar> resultIndexVars;
  for (size_t i = 0; i < tensor.getOrder(); ++i) {
    size_t idx = tensor.getFormat().getModeOrdering()[i];
    resultIndexVars.push_back(tensor.getIndexVars()[idx]); // adding i, j, k etc to the vector in the order in which they are stored
  }
  TensorPath resultTensorPath = TensorPath(tensor, resultIndexVars);

  struct CollectTensorPaths : public expr_nodes::ExprVisitor {
    vector<TensorPath> tensorPaths;
    map<IndexExpr,TensorPath> mapAccessNodesToPaths;
    void visit(const expr_nodes::AccessNode* op) { // Visting the access node like A(i,j)
      Format format = op->tensor.getFormat();

      // copy index variables to path
      vector<IndexVar> path(op->indexVars.size());
      for (size_t i=0; i < op->indexVars.size(); ++i) {
        path[i] = op->indexVars[format.getModeOrdering()[i]]; 
        // Add the indices i, j in the path depending upon what is the ordering specified
        // for that tensor
      }
      auto tensorPath = TensorPath(op->tensor, path);
      mapAccessNodesToPaths.insert({op, tensorPath});
      tensorPaths.push_back(tensorPath);
    }
  };
  CollectTensorPaths collect;
  expr.accept(&collect);
  util::append(tensorPaths, collect.tensorPaths);
  map<IndexExpr,TensorPath> mapAccessNodesToPaths = collect.mapAccessNodesToPaths;

  // Construct a forest decomposition from the tensor path graph
  // IterationScheduleForest can be found in src/lower/iteration_schedule_forest.h
  // and src/lower/iteration_schedule_forest.cpp
  IterationScheduleForest forest =
      IterationScheduleForest(util::combine({resultTensorPath},tensorPaths));

  // Create the iteration schedule
  IterationSchedule schedule = IterationSchedule();
  schedule.content =
      make_shared<IterationSchedule::Content>(tensor,
                                              forest,
                                              resultTensorPath,
                                              tensorPaths,
                                              mapAccessNodesToPaths);
}

## Iterators

class Iterators is defined in src/lower/iterators.h and it has following members:

-- map<TensorPath, storage::Iterator> roots
-- map<TensorPathStep, storage::Iterator> iterators


## Iterator

class Iterator can be found in src/storage/iterator.h

This class is the parent class to:
- DenseIterator
- SparseIterator
- FixedIterator
all defined in src/storage folder.

## DenseIterator
It has following data members
-- ir::Expr tensor
-- int level
-- ir::Expr ptrVar
-- ir::Expr idxVar
-- ir::Expr dimension

## SparseIterator
It has following members
-- ir::Expr tensor
-- int level
-- ir::Expr ptrVar
-- ir::Expr idxVar

## Module

class Module is defined in src/backends/module.h. It has following members

-- string source
-- string header
-- string libname
-- string tmpdir
-- vector<Stmt> funcs
-- Target target

Module::compile() {
  compileToSource()
  // actually compile using gcc
  system(cmd);
}

Module::compileToSource() {
  CodeGen_C codegen(source, CodeGen_C::OutputKind::C99Implementation);
  CodeGen_C headergen(header, CodeGen_C::OutputKind::C99Header);

  for ( func: funcs ) {
    codegen.compile(func);
    headergen.compile(func);
  } 

 source_file.open(path+prefix+".c");
 source_file << source.str();
}

## CodeGen_C
Is defined in src/backends/codegen_c.h

## Stmt
Is defined in include/taco/ir/ir.h

It has following data members:

## TensorPath
Contents:
  TensorBase tensor
  vector<IndexVar> vars

It is defined in src/lower/tensor_path.h

It has a pointer to Contents object

